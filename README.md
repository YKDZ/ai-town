# AI 小镇

在 AI 小镇的模拟系统中，每个居民都按照一个持续的行为循环运作。这个循环由大语言模型（LLM）驱动，使得每个居民能够根据其个性、记忆、时间和环境做出独立的决策。

通过命令启动项目，其打开一个 GUI 界面，显示一个 2D 的模拟小镇地图，小镇上住着几位 AI 居民，居民们的人物设定见 [人物设定](data/characters.json)。

小镇地图由中心广场、酒馆、图书馆和每户居民的家组成。

小镇地图有白天与黑夜轮转机制。每到黑夜，居民们就会在自己决定的时间回到自己的住所、上床睡觉；早上则会自己决定今天的日程。

故事的“主角”是 [格斯](data/characters.json)。他想要在三天后在小镇的中心广场举办一场联谊活动，并且想要让小镇的每个人都来参加。他在这三天内将会冲这这个目标规划自己的行为并努力实现它。

此项目意图在 GUI 中展示这三天内，小镇上每个居民的行为、他们间的交流过程以及最终一起联合达成目的的过程。

## 主循环

游戏主循环每次执行以下步骤：

### 1. 时间推进

- 每个循环周期推进游戏时间
- 维护昼夜交替机制
- 跟踪当前日期、星期和具体时间

### 2. 交互处理

系统自动检测并触发居民间的交互：

- **位置检测**：将所有居民按当前位置分组
- **交互条件**：
  - 同一位置至少有2名居民
  - 双方都不在睡觉或忙碌状态
  - 未处于交互冷却时间内
  - 随机概率触发（避免持续对话）
- **对话生成**：通过 LLM 为双方生成符合人格的对话内容
- **记忆更新**：将对话内容添加到双方的记忆中
- **冷却设置**：设置交互冷却时间，防止频繁重复对话

### 3. 居民行为更新

对每个居民执行独立的行为更新循环：

## 单个居民的行为循环

每个居民的行为循环包含以下阶段：

### 阶段 1：状态检查

系统首先检查居民的当前状态：

1. **忙碌检查**：如果居民正在执行某个行为（`busy_until` 未到期），跳过本次更新
2. **思考检查**：如果居民正在思考（LLM 正在生成决策），跳过本次更新

### 阶段 2：规划决策（Planning）

当居民空闲时，系统异步启动规划线程，通过 LLM 生成下一步行动：

#### 输入信息

居民决策时会考虑以下信息：

1. **个人档案**：
   - 姓名、年龄、职业
   - 个性、特征、名言
   - 人际关系

2. **当前状态**：
   - 当前日期和时间
   - 当前所在位置
   - 个人记忆（包括过去的经历和目标）

3. **环境信息**：
   - 所有可访问的地点及其描述
   - 其他居民的当前位置和状态
   - 公告板信息（如果在小镇广场）

#### LLM 决策过程

系统使用结构化提示词（见 `src/ai/prompts.py`）引导 LLM 生成决策：

**系统提示词**包含：
- 居民完整的人物设定
- 全局行为规则（时间感知、地点限制等）
- 可用地点列表
- 其他居民位置信息

**用户提示词**包含：
- 当前日期、时间、位置
- 个人记忆和目标

**输出格式**（JSON）：

```json
{
  "action": "行为描述（英文）",
  "target_location": "目标地点",
  "dialogue": "想说的话（中文）",
  "emoji": "代表性表情符号",
  "duration": "持续时间（分钟）"
}
```

#### 决策规则

居民在做决策时会遵循以下规则：

1. **时间感知**：深夜时（22:00后）会考虑回家睡觉
2. **位置选择**：只能前往已连接的地点
3. **社交意识**：可以查看其他人在哪里，决定是否去找他们
4. **目标导向**：会根据个人目标（如格斯的聚会计划）规划行为
5. **公告发布**：在小镇广场可以使用 "Post Notice" 行为在公告板发布消息

### 阶段 3：执行行为

LLM 生成决策后，系统执行以下操作：

1. **移动**：如果目标位置与当前位置不同，更新居民位置
2. **特殊行为处理**：
   - **发布公告**：如果在广场执行 "Post Notice"，将消息添加到公告板
3. **状态更新**：
   - 更新居民的状态文本（显示当前行为和对话）
   - 更新表情符号
   - 设置忙碌时间（`busy_until`），在此期间不会规划新行为
4. **记录日志**：记录行为到模拟日志中

### 阶段 4：特殊处理 - 睡眠与记忆优化

当居民决定睡觉时（行为持续时间超过120分钟），系统会触发记忆优化：

**记忆压缩机制**：、

- **触发条件**：
  - 处于睡觉状态
  - 持续时间超过120分钟
  - 当天尚未优化过记忆
  
- **优化过程**：
  1. 收集当天的所有记忆
  2. 通过 LLM 生成记忆摘要
  3. 用摘要替换原始记忆
  4. 保留日期标记维护连续性

- **目的**：
  - 模拟人类夜间记忆巩固
  - 保持重要信息的同时显著节省 token 消耗

## 居民可执行的行为类型

根据代码分析和角色设定，居民可以执行以下类型的行为：

### 1. 移动行为

- **Go to [地点]**：前往指定地点
- 例如："Go to Saloon"（去酒馆）、"Go to Library"（去图书馆）

### 2. 社交行为

- **Chat with [人名]**：与特定居民交谈
- **对话系统**：自动触发，双方通过 LLM 生成真实对话内容
- 对话会被记录到双方记忆中

### 3. 日常行为

- **Work**：工作（根据职业）
- **Eat/Breakfast**：用餐
- **Read**：阅读（通常在图书馆）
- **Relax**：放松休息

### 4. 休息行为

- **Sleep**：睡觉（触发记忆优化）
- **Rest**：休息

### 5. 特殊行为

- **Post Notice**：在小镇广场公告板发布消息
- **研究、实验、探险**等职业相关行为

### 6. 空闲行为

- **Idle**：无特定活动，思考或观察周围

## 时间流逝与昼夜循环

### 昼夜机制

- **白天**（06:00-22:00）：居民活跃期，进行各种活动
- **夜晚**（22:00-06:00）：大多数居民会回家睡觉
- 居民会根据时间自主决定何时回家

### 行为持续时间

- 最短持续时间：50分钟（由提示词约束）
- 典型持续时间：60-120分钟（默认为60分钟，可通过 `Config.DEFAULT_ACTION_DURATION` 配置）
- 睡眠时间：通常8小时以上（480分钟）
- 对话后忙碌时长：45分钟（可通过 `Config.CONVERSATION_BUSY_DURATION` 配置）

### 日程感知

- 居民具有强烈的日期意识
- 可以规划未来特定日期的活动
- 通过记忆系统追踪重要事件

## 记忆系统

### 记忆类型

1. **初始记忆**：角色的特殊任务和背景
2. **对话记忆**：与其他居民的交流内容
3. **行为记忆**：重要的行动和决定
4. **优化记忆**：每日摘要（夜间生成）

### 记忆格式

```
[时间戳] 事件描述
```

例如：
```
[2025-01-01 10:30] I chatted with Emily. I said: '...' They replied: '...'
```

### 记忆影响

- 居民的所有决策都基于记忆
- 记忆帮助维持人格一致性
- 记忆驱动长期目标的实现

## 交互冷却机制

为避免居民反复触发相同交互：

- **冷却时间**：两人对话后，会设置150分钟（2.5小时）的冷却期（可通过 `Config.INTERACTION_COOLDOWN_MINUTES` 配置）
- **冷却作用**：在冷却期内，同一对居民不会再次自动对话
- **交互概率**：即使没有冷却，也有40%的随机概率控制对话触发（可通过 `Config.INTERACTION_PROBABILITY` 配置）

## 模拟结束条件

模拟会在以下情况结束：
1. 达到设定的模拟天数（默认3天，可通过 `Config.SIMULATION_DURATION_DAYS` 配置）
2. 所有居民都处于睡眠状态
3. 用户手动停止模拟

## 日志记录

系统记录以下事件：

- **plan**：居民的行为规划
- **dialogue**：居民间的对话
- **notice**：公告板发布

日志可用于回放模拟过程。

## 技术实现要点

### 异步处理

- LLM 调用在独立线程中进行
- 避免阻塞主模拟循环
- 多个居民可以同时进行决策

### 状态同步

- 使用 `is_thinking` 标志防止重复规划
- 使用 `busy_until` 控制行为持续时间
- 保证居民状态的一致性

### LLM 集成

- 支持 OpenAI API 风格接口
- 可为每个居民配置独立的 LLM 客户端
- 结构化 JSON 输出确保可靠解析